/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "oauth.h"
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <iostream>
#include <fstream>
#include <set>
#include <vector>
#include <sstream>

using namespace std;

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif

set<string> users;
set<string> resources;
vector<vector<approve_entry>> approvals;
int operation_number;

void split_str(string &str, char delim, vector<string> &out ) {  
	std::stringstream s(str);
	std::string s2;
	while (getline(s, s2, delim))
		out.push_back(s2);
}

static void
oauth_prog_1(struct svc_req *rqstp, register SVCXPRT *transp)
{
	union {
		request_authorization_information request_authorization_1_arg;
		request_access_token_information request_access_token_1_arg;
		validate_delegated_action_information validate_delegated_action_1_arg;
		approve_request_token_information approve_request_token_1_arg;
	} argument;
	char *result;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct svc_req *);

	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
		return;

	case request_authorization:
		_xdr_argument = (xdrproc_t) xdr_request_authorization_information;
		_xdr_result = (xdrproc_t) xdr_wrapstring;
		local = (char *(*)(char *, struct svc_req *)) request_authorization_1_svc;
		break;

	case request_access_token:
		_xdr_argument = (xdrproc_t) xdr_request_access_token_information;
		_xdr_result = (xdrproc_t) xdr_request_access_token_response;
		local = (char *(*)(char *, struct svc_req *)) request_access_token_1_svc;
		break;

	case validate_delegated_action:
		_xdr_argument = (xdrproc_t) xdr_validate_delegated_action_information;
		_xdr_result = (xdrproc_t) xdr_wrapstring;
		local = (char *(*)(char *, struct svc_req *)) validate_delegated_action_1_svc;
		break;

	case approve_request_token:
		_xdr_argument = (xdrproc_t) xdr_approve_request_token_information;
		_xdr_result = (xdrproc_t) xdr_approve_request_token_information;
		local = (char *(*)(char *, struct svc_req *)) approve_request_token_1_svc;
		break;

	default:
		svcerr_noproc (transp);
		return;
	}
	memset ((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		svcerr_decode (transp);
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
		svcerr_systemerr (transp);
	}
	if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		fprintf (stderr, "%s", "unable to free arguments");
		exit (1);
	}
	return;
}

int
main (int argc, char **argv)
{
	setbuf(stdout, NULL);
	register SVCXPRT *transp;

	pmap_unset (OAUTH_PROG, OUATH_VERS);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, OAUTH_PROG, OUATH_VERS, oauth_prog_1, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (OAUTH_PROG, OUATH_VERS, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, OAUTH_PROG, OUATH_VERS, oauth_prog_1, IPPROTO_TCP)) {
		fprintf (stderr, "%s", "unable to register (OAUTH_PROG, OUATH_VERS, tcp).");
		exit(1);
	}

	ifstream clients_in(argv[1]);
	int clients_count; clients_in >> clients_count;
	for (int i = 0; i < clients_count; i++) {
		string user_id;
		clients_in >> user_id;
		users.insert(user_id);
	}
	clients_in.close();

	ifstream resources_in(argv[2]);
	int resources_count; resources_in >> resources_count;
	for (int i = 0; i < resources_count; i++) {
		string resource_name;
		resources_in >> resource_name;
		resources.insert(resource_name);
	}
	resources_in.close();

	ifstream approvals_in(argv[3]);
	string line;
	while (getline(approvals_in, line)) {
		vector<string> approval_line;
		vector<approve_entry> approve_entries;
		split_str(line, ',', approval_line);
		for (unsigned int i = 0; i < approval_line.size() - 1; i += 2) {
			approve_entry entry;
			entry.resource = (char *)calloc(approval_line[i].length(), sizeof(char));
			memcpy(entry.resource, approval_line[i].c_str(), approval_line[i].length());
			memcpy(entry.permissions, approval_line[i + 1].c_str(), 5);
			approve_entries.push_back(entry);
		}
		approvals.push_back(approve_entries);
	}
	approvals_in.close();

	operation_number = atoi(argv[4]);

	svc_run ();
	fprintf (stderr, "%s", "svc_run returned");
	exit (1);
	/* NOTREACHED */
}
