/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "oauth.h"
#include "token.h"
#include <set>
#include <string>
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;

typedef struct user {
	string user_id;
	vector<approve_entry> approvals;
	string refresh_token;
	string auth_token;
	int operations_left;
} user;

unordered_map<string, string> operations = {
	{"READ", "R"},
	{"EXECUTE", "X"},
	{"DELETE", "D"},
	{"INSERT", "I"},
	{"MODIFY", "M"}
};

extern set<string> users;
extern set<string> resources;
extern vector<vector<approve_entry>> approvals;
extern int operation_number;
unordered_map<string, string> user_id_auth_token;
unordered_map<string, user> users_db;
unordered_map<string, vector<approve_entry>> authorization_token_approvals;

char **
request_authorization_1_svc(request_authorization_information *argp, struct svc_req *rqstp)
{
	static char * result;

	cout << "BEGIN " << argp->user_id << " AUTHZ" << endl;
	if (users.find(argp->user_id) == users.end()) {
		result = (char *) "USER_NOT_FOUND";
		return &result;
	}

	result = generate_access_token(argp->user_id);
	cout << "  RequestToken = " << result << endl;
	user_id_auth_token[string(result)] = string(argp->user_id);

	return &result;
}

request_access_token_response *
request_access_token_1_svc(request_access_token_information *argp, struct svc_req *rqstp)
{
	static request_access_token_response  result;

	if (argp->auto_refresh != 2) {
		unordered_map<string, string>::const_iterator pair = user_id_auth_token.find(argp->authorization_token);
		if (pair == user_id_auth_token.end()) {
			memcpy(result.access_token, "REQUEST_DENIED", 16);
			return &result;
		}

		unordered_map<string, vector<approve_entry>>::const_iterator approval_pair =
			authorization_token_approvals.find(argp->authorization_token);
		if (approval_pair == authorization_token_approvals.end()) {
			memcpy(result.access_token, "REQUEST_DENIED", 16);
			return &result;
		}

		user new_user;
		new_user.approvals = authorization_token_approvals[argp->authorization_token];
		new_user.user_id = argp->user_id;
		new_user.operations_left = operation_number;
		new_user.auth_token = argp->authorization_token;

		memcpy(result.access_token, generate_access_token(argp->authorization_token), 16);
		cout << "  AccessToken = " << result.access_token << endl;

		if (argp->auto_refresh == 1) {
			char *refresh_token = generate_access_token(result.access_token);
			memcpy(result.refresh_token, refresh_token, 16);
			cout << "  RefreshToken = " << result.refresh_token << endl;
			new_user.refresh_token = refresh_token;
		}

		result.valability = operation_number;
		users_db[result.access_token] = new_user;

		return &result;
	} else {
		user refresh_user = users_db[argp->authorization_token];
		char *new_access = generate_access_token((char *)refresh_user.refresh_token.c_str());
		char *new_refresh = generate_access_token(new_access);
		user new_user;
		cout << "BEGIN " << refresh_user.user_id << " AUTHZ REFRESH" << endl;
		new_user.approvals = refresh_user.approvals;
		new_user.operations_left = operation_number;
		new_user.refresh_token = new_refresh;
		new_user.user_id = refresh_user.user_id;
		new_user.auth_token = refresh_user.auth_token;

		users_db[new_access] = new_user;
		cout << "  AccessToken = " << new_access << endl;
		cout << "  RefreshToken = " << new_refresh << endl;
		users_db.erase(argp->authorization_token);
		memcpy(result.access_token, new_access, 16);
		memcpy(result.refresh_token, new_refresh, 16);
		result.valability = operation_number;

		return &result;
	}
}

char **
validate_delegated_action_1_svc(validate_delegated_action_information *argp, struct svc_req *rqstp)
{
	static char * result;

	unordered_map<string, user>::iterator pair = users_db.find(argp->access_token);
	if (pair == users_db.end()) {
		cout << "DENY (" << argp->operation << "," << argp->resource << "," << argp->access_token << "," << 0 << ")" << endl;
		result = (char *) "PERMISSION_DENIED";
		return &result;
	}

	set<string>::iterator value = resources.find(argp->resource);
	if (value == resources.end()) {
		pair->second.operations_left--;
		cout << "DENY (" << argp->operation << "," << argp->resource << "," << argp->access_token << "," << pair->second.operations_left << ")" << endl;
		result = (char *) "RESOURCE_NOT_FOUND";
		return &result;
	}

	if (pair->second.operations_left == 0) {
		result = (char *) "TOKEN_EXPIRED";
		users_db.erase(argp->access_token);
		authorization_token_approvals.erase(argp->access_token);
		cout << "DENY (" << argp->operation << "," << argp->resource << ",," << pair->second.operations_left << ")" << endl;
		return &result;
	}

	for (auto approval : pair->second.approvals) {
		if (strcmp(argp->resource, approval.resource) == 0) {
			for (auto character : approval.permissions) {
				if (character ==  operations[argp->operation][0]) {
					pair->second.operations_left--;
					cout << "PERMIT (" << argp->operation << "," << argp->resource << "," << argp->access_token << "," << pair->second.operations_left << ")" << endl;
					result = (char *) "PERMISSION_GRANTED";
					return &result;
				}
			}
			break;
		}
	}

	pair->second.operations_left--;
	cout << "DENY (" << argp->operation << "," << argp->resource << "," << argp->access_token << "," << pair->second.operations_left << ")" << endl;
	result = (char *) "OPERATION_NOT_PERMITTED";
	return &result;
}

approve_request_token_information *
approve_request_token_1_svc(approve_request_token_information *argp, struct svc_req *rqstp)
{
	static approve_request_token_information result;

	memcpy(result.access_token, argp->access_token, 16);
	if (approvals[0][0].resource[0] == '*') {
		result.sign = 0;
	} else {
		authorization_token_approvals[argp->access_token] = approvals[0];
		result.sign = 1;
	}

	approvals.erase(approvals.begin());

	return &result;
}
