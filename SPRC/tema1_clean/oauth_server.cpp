/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "oauth.h"
#include "token.h"
#include <set>
#include <string>
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;

// the information held for one user in the database
typedef struct user {
	string user_id;
	vector<approve_entry> approvals;
	string refresh_token;
	string auth_token;
	int operations_left;
} user;

// map with the permitted operations
unordered_map<string, string> operations = {
	{"READ", "R"},
	{"EXECUTE", "X"},
	{"DELETE", "D"},
	{"INSERT", "I"},
	{"MODIFY", "M"}
};

// set with the users
extern set<string> users;
// set with the resources
extern set<string> resources;
// a list with the approvals
extern vector<vector<approve_entry>> approvals;
// the number of operations read from the given file
extern int operation_number;
// map from the user id to the authorization token
unordered_map<string, string> user_id_auth_token;
// users database
unordered_map<string, user> users_db;
// save the approvals when the request for the authorization token to be signed is received by the server
unordered_map<string, vector<approve_entry>> authorization_token_approvals;

char **
request_authorization_1_svc(request_authorization_information *argp, struct svc_req *rqstp)
{
	static char * result;

	cout << "BEGIN " << argp->user_id << " AUTHZ" << endl;
	if (users.find(argp->user_id) == users.end()) {
		result = (char *) "USER_NOT_FOUND";
		return &result;
	}

	result = generate_access_token(argp->user_id);
	cout << "  RequestToken = " << result << endl;
	user_id_auth_token[string(result)] = string(argp->user_id);

	return &result;
}

request_access_token_response *
request_access_token_1_svc(request_access_token_information *argp, struct svc_req *rqstp)
{
	static request_access_token_response  result;

	// generate the access token normaly
	if (argp->auto_refresh != 2) {
		// check if we have a authorization token for the user
		unordered_map<string, string>::const_iterator pair = user_id_auth_token.find(argp->authorization_token);
		if (pair == user_id_auth_token.end()) {
			memcpy(result.access_token, "REQUEST_DENIED", 16);
			return &result;
		}

		// check if we have a set of approvals for the user
		unordered_map<string, vector<approve_entry>>::const_iterator approval_pair =
			authorization_token_approvals.find(argp->authorization_token);
		if (approval_pair == authorization_token_approvals.end()) {
			memcpy(result.access_token, "REQUEST_DENIED", 16);
			return &result;
		}

		// add the new user to the database
		user new_user;
		new_user.approvals = authorization_token_approvals[argp->authorization_token];
		new_user.user_id = argp->user_id;
		new_user.operations_left = operation_number;
		new_user.auth_token = argp->authorization_token;

		// generate the access token
		memcpy(result.access_token, generate_access_token(argp->authorization_token), 16);
		cout << "  AccessToken = " << result.access_token << endl;

		// generate the access token if it is needed
		if (argp->auto_refresh == 1) {
			char *refresh_token = generate_access_token(result.access_token);
			memcpy(result.refresh_token, refresh_token, 16);
			cout << "  RefreshToken = " << result.refresh_token << endl;
			new_user.refresh_token = refresh_token;
		}

		result.valability = operation_number;
		users_db[result.access_token] = new_user;

		return &result;
	} else {
		// in case of auto refresh of the access token
		user refresh_user = users_db[argp->authorization_token];
		// generate the new access token from the refresh token
		char *new_access = generate_access_token(argp->user_id);
		// generate the new refresh token from the new access token
		char *new_refresh = generate_access_token(new_access);
		user new_user;
		cout << "BEGIN " << refresh_user.user_id << " AUTHZ REFRESH" << endl;
		// update the new user and insert it in the database
		new_user.approvals = refresh_user.approvals;
		new_user.operations_left = operation_number;
		new_user.refresh_token = new_refresh;
		new_user.user_id = refresh_user.user_id;
		new_user.auth_token = refresh_user.auth_token;

		users_db[new_access] = new_user;
		cout << "  AccessToken = " << new_access << endl;
		cout << "  RefreshToken = " << new_refresh << endl;
		// erase the access token from the user database
		users_db.erase(argp->authorization_token);
		memcpy(result.access_token, new_access, 16);
		memcpy(result.refresh_token, new_refresh, 16);
		result.valability = operation_number;

		return &result;
	}
}

char **
validate_delegated_action_1_svc(validate_delegated_action_information *argp, struct svc_req *rqstp)
{
	static char * result;

	unordered_map<string, user>::iterator pair = users_db.find(argp->access_token);
	// check if the user exists in the database
	if (pair == users_db.end()) {
		cout << "DENY (" << argp->operation << "," << argp->resource << "," << argp->access_token << "," << 0 << ")" << endl;
		result = (char *) "PERMISSION_DENIED";
		return &result;
	}

	// check if the resource exists
	set<string>::iterator value = resources.find(argp->resource);
	if (value == resources.end()) {
		pair->second.operations_left--;
		cout << "DENY (" << argp->operation << "," << argp->resource << "," << argp->access_token << "," << pair->second.operations_left << ")" << endl;
		result = (char *) "RESOURCE_NOT_FOUND";
		return &result;
	}

	// check if the user has operations left
	if (pair->second.operations_left == 0) {
		result = (char *) "TOKEN_EXPIRED";
		users_db.erase(argp->access_token);
		authorization_token_approvals.erase(argp->access_token);
		cout << "DENY (" << argp->operation << "," << argp->resource << ",," << pair->second.operations_left << ")" << endl;
		return &result;
	}

	// if the operation is valid
	if (operations.find(argp->operation) != operations.end()) {
		for (auto approval : pair->second.approvals) {
			// check if we find the resource among approval set
			if (strcmp(argp->resource, approval.resource) == 0) {
				for (auto character : approval.permissions) {
					// check if the operation is permitted on the resource
					if (character ==  operations[argp->operation][0]) {
						pair->second.operations_left--;
						cout << "PERMIT (" << argp->operation << "," << argp->resource << "," << argp->access_token << "," << pair->second.operations_left << ")" << endl;
						result = (char *) "PERMISSION_GRANTED";
						return &result;
					}
				}
				break;
			}
		}
	}

	pair->second.operations_left--;
	cout << "DENY (" << argp->operation << "," << argp->resource << "," << argp->access_token << "," << pair->second.operations_left << ")" << endl;
	result = (char *) "OPERATION_NOT_PERMITTED";
	return &result;
}

approve_request_token_information *
approve_request_token_1_svc(approve_request_token_information *argp, struct svc_req *rqstp)
{
	static approve_request_token_information result;

	memcpy(result.access_token, argp->access_token, 16);
	// extract the approval from the vector in FIFO order
	if (approvals[0][0].resource[0] == '*') {
		result.sign = 0;
	} else {
		authorization_token_approvals[argp->access_token] = approvals[0];
		result.sign = 1;
	}

	// remove the first element
	approvals.erase(approvals.begin());

	return &result;
}
